// This file is @generated by prost-build.
/// Timestamp message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Timestamp {
    #[prost(uint64, tag = "1")]
    pub nanos: u64,
}
/// Order side
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Side {
    Buy = 0,
    Sell = 1,
}
impl Side {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Side::Buy => "BUY",
            Side::Sell => "SELL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "BUY" => Some(Self::Buy),
            "SELL" => Some(Self::Sell),
            _ => None,
        }
    }
}
/// Order type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OrderType {
    Limit = 0,
    Market = 1,
}
impl OrderType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            OrderType::Limit => "LIMIT",
            OrderType::Market => "MARKET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "LIMIT" => Some(Self::Limit),
            "MARKET" => Some(Self::Market),
            _ => None,
        }
    }
}
/// Reject reasons matching the C++ protocol
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RejectReason {
    None = 0,
    InvalidSymbol = 1,
    InvalidPrice = 2,
    InvalidQuantity = 3,
    DuplicateOrderId = 4,
    UnknownOrder = 5,
    InsufficientFunds = 6,
    MarketClosed = 7,
    SystemError = 8,
}
impl RejectReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            RejectReason::None => "NONE",
            RejectReason::InvalidSymbol => "INVALID_SYMBOL",
            RejectReason::InvalidPrice => "INVALID_PRICE",
            RejectReason::InvalidQuantity => "INVALID_QUANTITY",
            RejectReason::DuplicateOrderId => "DUPLICATE_ORDER_ID",
            RejectReason::UnknownOrder => "UNKNOWN_ORDER",
            RejectReason::InsufficientFunds => "INSUFFICIENT_FUNDS",
            RejectReason::MarketClosed => "MARKET_CLOSED",
            RejectReason::SystemError => "SYSTEM_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "INVALID_SYMBOL" => Some(Self::InvalidSymbol),
            "INVALID_PRICE" => Some(Self::InvalidPrice),
            "INVALID_QUANTITY" => Some(Self::InvalidQuantity),
            "DUPLICATE_ORDER_ID" => Some(Self::DuplicateOrderId),
            "UNKNOWN_ORDER" => Some(Self::UnknownOrder),
            "INSUFFICIENT_FUNDS" => Some(Self::InsufficientFunds),
            "MARKET_CLOSED" => Some(Self::MarketClosed),
            "SYSTEM_ERROR" => Some(Self::SystemError),
            _ => None,
        }
    }
}
